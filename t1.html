<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=no">
<title>Jigsaw Puzzle</title>

<style>
*{margin:0;padding:0;box-sizing:border-box}
body{
  font-family:sans-serif;background:#111;color:#fff;
  overflow:hidden;position:fixed;width:100%;height:100%;
}
#header{
  position:absolute;top:0;left:0;right:0;padding:12px 20px;
  background:rgba(0,0,0,.4);backdrop-filter:blur(10px);
  display:flex;justify-content:space-between;z-index:20;
}
#timer,#title{font-size:18px;font-weight:bold}
canvas{touch-action:none;cursor:grab}
canvas:active{cursor:grabbing}
#loading,#completionModal{
  position:fixed;top:0;left:0;width:100%;height:100%;
  display:flex;align-items:center;justify-content:center;
  background:rgba(0,0,0,.8);backdrop-filter:blur(10px);
  z-index:50;
}
#completionModal{display:none}
.modal-content{
  background:#222;padding:30px;border-radius:14px;text-align:center;
}
.modal-content button{
  margin-top:10px;padding:12px 28px;background:#4ade80;border:0;
  color:white;font-size:16px;border-radius:8px;cursor:pointer;
}
</style>
</head>
<body>

<div id="loading"><h3>Loading puzzle...</h3></div>

<div id="header">
 <div id="title">Jigsaw Puzzle</div>
 <div id="timer">00:00</div>
</div>

<canvas id="puzzleCanvas"></canvas>

<div id="completionModal">
 <div class="modal-content">
   <h2>✅ Puzzle Completed!</h2>
   <p>Time: <span id="finalTime"></span></p>
   <button onclick="resetPuzzle()">Play Again</button>
 </div>
</div>

<script>
/* CONFIG */
const COLS=4, ROWS=4, SNAP=30;
const IMG="./assets/puzzle.jpg";

/* Vars */
let canvas,ctx,img,pieces=[],drag=null,off={},start,tmr,done=false;
let pw,ph,w,h,ox,oy;

window.onload=()=>{
 canvas=document.getElementById("puzzleCanvas");
 ctx=canvas.getContext("2d");
 loadImage();
};

function loadImage(){
 img=new Image();
 img.onload=()=>{document.getElementById("loading").style.display="none"; setup();};
 img.src=IMG;
}

function setup(){
 const head=60,pad=10,aw=innerWidth-pad*2,ah=innerHeight-head-pad*2;
 const r=img.width/img.height;
 if(aw/ah>r){h=ah;w=h*r;} else{w=aw;h=w/r;}

 canvas.width=innerWidth;canvas.height=innerHeight;
 pw=w/COLS;ph=h/ROWS;
 ox=(innerWidth-w)/2;oy=(innerHeight-h)/2+head/2;

 createPieces(); scatter(); startClock(); events(); drawLoop();
}

/* Create puzzle pieces w/ irregular edges */
function createPieces(){
 pieces=[];
 for(let r=0;r<ROWS;r++){
  for(let c=0;c<COLS;c++){
   let p={row:r,col:c,cx:ox+c*pw,cy:oy+r*ph,x:0,y:0,placed:false,z:r*COLS+c,edges:{}};

   p.edges.top = r===0?0:(pieces[(r-1)*COLS+c].edges.bottom*-1);
   p.edges.left = c===0?0:(pieces[pieces.length-1].edges.right*-1);
   p.edges.bottom = r===ROWS-1?0:(Math.random()>0.5?1:-1);
   p.edges.right = c===COLS-1?0:(Math.random()>0.5?1:-1);

   pieces.push(p);
  }
 }
}

/* Scatter pieces randomly */
function scatter(){
 const m=60,gc=Math.ceil(Math.sqrt(pieces.length));
 const gs=Math.min((innerWidth-m*2)/gc,(innerHeight-m*2)/gc);
 pieces.forEach((p,i)=>{
  let r=Math.floor(i/gc),c=i%gc;
  p.x=m+c*gs+(Math.random()*(gs-pw));
  p.y=m+r*gs+(Math.random()*(gs-ph));
 });
}

/* Mouse/touch helpers */
function getPos(e){
 let r=canvas.getBoundingClientRect();
 let X=e.touches?e.touches[0].clientX:e.clientX;
 let Y=e.touches?e.touches[0].clientY:e.clientY;
 return{x:X-r.left,y:Y-r.top}
}

function events(){
 canvas.onmousedown=startDrag;canvas.onmousemove=move;canvas.onmouseup=endDrag;
 canvas.ontouchstart=startDrag;canvas.ontouchmove=move;canvas.ontouchend=endDrag;
}

function startDrag(e){
 if(done)return;
 let p=getPos(e);
 pieces.sort((a,b)=>b.z-a.z).some(pc=>{
  if(!pc.placed&&p.x>=pc.x&&p.x<=pc.x+pw&&p.y>=pc.y&&p.y<=pc.y+ph){
   drag=pc;off={x:p.x-pc.x,y:p.y-pc.y};
   pc.z=Math.max(...pieces.map(x=>x.z))+1;return true;
  }
 });
}

function move(e){
 if(!drag)return;let p=getPos(e);
 drag.x=p.x-off.x;drag.y=p.y-off.y;
}

function endDrag(){
 if(!drag)return;
 let dx=drag.x-drag.cx,dy=drag.y-drag.cy;
 if(Math.hypot(dx,dy)<SNAP){drag.x=drag.cx;drag.y=drag.cy;drag.placed=true;}
 drag=null;checkDone();
}

/* Puzzle shape path */
function shape(ctx,x,y,w,h,e){
 const t=Math.min(w,h)*0.25;
 ctx.beginPath();
 ctx.moveTo(x,y+h/2);
 if(e.left===0)ctx.lineTo(x,y);
 else{
  let d=e.left;
  ctx.bezierCurveTo(x-t*d,y+h*.2,x-t*d,y+h*.8,x,y+h);
 }
 if(e.bottom===0)ctx.lineTo(x+w,y+h);
 else{
  let d=e.bottom;
  ctx.bezierCurveTo(x+w*.2,y+h+t*d,x+w*.8,y+h+t*d,x+w,y+h);
 }
 if(e.right===0)ctx.lineTo(x+w,y);
 else{
  let d=e.right;
  ctx.bezierCurveTo(x+w+t*d,y+h*.8,x+w+t*d,y+h*.2,x+w,y);
 }
 if(e.top===0)ctx.lineTo(x,y);
 else{
  let d=e.top;
  ctx.bezierCurveTo(x+w*.8,y-t*d,x+w*.2,y-t*d,x,y);
 }
 ctx.closePath();
}

/* Main draw loop */
function drawLoop(){
 ctx.clearRect(0,0,innerWidth,innerHeight);

 /* ✅ Faint image guide (helps player) */
 ctx.globalAlpha=0.15;
 ctx.drawImage(img,ox,oy,w,h);
 ctx.globalAlpha=1;

 /* ✅ Ghost grid outlines */
 pieces.forEach(p=>{
  if(!p.placed){
   ctx.save();
   shape(ctx,p.cx,p.cy,pw,ph,p.edges);
   ctx.strokeStyle="rgba(255,255,255,0.15)";
   ctx.lineWidth=1;
   ctx.stroke();
   ctx.restore();
  }
 });

 /* Draw pieces */
 pieces.sort((a,b)=>a.z-b.z).forEach(p=>{
  let sx=p.col*(img.width/COLS);
  let sy=p.row*(img.height/ROWS);
  let sw=img.width/COLS,sh=img.height/ROWS;

  ctx.save();
  shape(ctx,p.x,p.y,pw,ph,p.edges);
  ctx.clip();
  ctx.drawImage(img,sx,sy,sw,sh,p.x,p.y,pw,ph);
  ctx.restore();

  ctx.strokeStyle=p.placed?"rgba(0,255,0,0.4)":"rgba(255,255,255,0.4)";
  ctx.lineWidth=1.3;
  shape(ctx,p.x,p.y,pw,ph,p.edges);ctx.stroke();
 });

 requestAnimationFrame(drawLoop);
}

/* Timer & completion */
function startClock(){
 start=Date.now();
 clearInterval(tmr);
 tmr=setInterval(()=>{
  if(done)return;
  let t=Math.floor((Date.now()-start)/1000);
  document.getElementById("timer").textContent =
    `${String(Math.floor(t/60)).padStart(2,"0")}:${String(t%60).padStart(2,"0")}`;
 },1000);
}

function checkDone(){
 if(pieces.every(p=>p.placed)){
  done=true;clearInterval(tmr);
  document.getElementById("finalTime").textContent=document.getElementById("timer").textContent;
  setTimeout(()=>document.getElementById("completionModal").style.display="flex",400);
 }
}
function checkDone(){
 if(pieces.every(p=>p.placed)){
   done=true;
   clearInterval(tmr);

   // ✅ Draw completed full image (clean, no cuts)
   ctx.clearRect(0,0,innerWidth,innerHeight);
   ctx.drawImage(img, ox, oy, w, h);
   
   // ✅ Optional: draw faint outlines around pieces (remove if you don't want outlines)
   pieces.forEach(p=>{
     ctx.strokeStyle="rgba(0,0,0,0.2)";
     ctx.lineWidth=1;
     shape(ctx,p.cx,p.cy,pw,ph,p.edges);
     ctx.stroke();
   });

   // Show modal AFTER showing finished picture
   document.getElementById("finalTime").textContent =
     document.getElementById("timer").textContent;
   setTimeout(()=>document.getElementById("completionModal").style.display="flex",400);
 }
}


function resetPuzzle(){
 document.getElementById("completionModal").style.display="none";
 done=false;pieces.forEach(p=>p.placed=false);
 scatter();startClock();
}
</script>
</body>
</html>


