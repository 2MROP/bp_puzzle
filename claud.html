<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Jigsaw Puzzle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        #header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 15px 20px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            z-index: 10;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #timer {
            font-size: 18px;
            font-weight: 600;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        #title {
            font-size: 20px;
            font-weight: 700;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        #puzzleCanvas {
            cursor: grab;
            max-width: 100%;
            max-height: 100%;
            touch-action: none;
        }

        #puzzleCanvas:active {
            cursor: grabbing;
        }

        #completionModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        #completionModal.show {
            display: flex;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: linear-gradient(135deg, #2a2a3e 0%, #1f2937 100%);
            padding: 40px 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            max-width: 90%;
            animation: slideUp 0.4s ease;
        }

        @keyframes slideUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-content h2 {
            font-size: 32px;
            margin-bottom: 15px;
            color: #4ade80;
            text-shadow: 0 0 20px rgba(74, 222, 128, 0.3);
        }

        .modal-content p {
            font-size: 18px;
            margin-bottom: 10px;
            color: #e5e7eb;
        }

        .modal-content button {
            margin-top: 25px;
            padding: 15px 40px;
            font-size: 18px;
            font-weight: 600;
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            color: #fff;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(74, 222, 128, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .modal-content button:active {
            transform: scale(0.95);
            box-shadow: 0 2px 10px rgba(74, 222, 128, 0.4);
        }

        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            flex-direction: column;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top-color: #4ade80;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #loading p {
            margin-top: 20px;
            font-size: 16px;
            color: #9ca3af;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <p>Loading puzzle...</p>
    </div>

    <div id="container">
        <div id="header">
            <div id="title">Jigsaw Puzzle</div>
            <div id="timer">00:00</div>
        </div>
        <canvas id="puzzleCanvas"></canvas>
    </div>

    <div id="completionModal">
        <div class="modal-content">
            <h2>ðŸŽ‰ Puzzle Completed!</h2>
            <p>Time: <span id="finalTime"></span></p>
            <button onclick="resetPuzzle()">Play Again</button>
        </div>
    </div>

    <script>
        // ==================== CONFIGURATION ====================
        const PUZZLE_COLS = 4;
        const PUZZLE_ROWS = 6;
        const SNAP_DISTANCE = 30;
        const IMAGE_PATH = './assets/puzzle.jpg';

        // ==================== GAME STATE ====================
        let canvas, ctx;
        let pieces = [];
        let draggedPiece = null;
        let dragOffset = { x: 0, y: 0 };
        let puzzleImage = null;
        let startTime = null;
        let timerInterval = null;
        let pieceWidth, pieceHeight;
        let puzzleWidth, puzzleHeight;
        let offsetX, offsetY;
        let isCompleted = false;
        let animationFrame = null;

        // ==================== INITIALIZATION ====================
        window.addEventListener('load', init);

        function init() {
            canvas = document.getElementById('puzzleCanvas');
            ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
            
            // Prevent default touch behaviors and scrolling
            document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
            document.addEventListener('gesturestart', (e) => e.preventDefault());
            document.addEventListener('gesturechange', (e) => e.preventDefault());
            document.addEventListener('gestureend', (e) => e.preventDefault());
            
            loadImage();
        }

        function loadImage() {
            puzzleImage = new Image();
            puzzleImage.onload = () => {
                setupPuzzle();
                document.getElementById('loading').style.display = 'none';
            };
            puzzleImage.onerror = () => {
                document.getElementById('loading').innerHTML = 
                    '<p style="color: #ef4444; padding: 20px; text-align: center;">Failed to load puzzle.jpg<br><br>Please ensure the image is located at:<br>./assets/puzzle.jpg</p>';
            };
            puzzleImage.src = IMAGE_PATH;
        }

        // ==================== PUZZLE SETUP ====================
        function setupPuzzle() {
            const headerHeight = 60;
            const padding = 20;
            const availableWidth = window.innerWidth - padding * 2;
            const availableHeight = window.innerHeight - headerHeight - padding * 2;
            
            const imageAspect = puzzleImage.width / puzzleImage.height;
            
            // Maintain aspect ratio
            if (availableWidth / availableHeight > imageAspect) {
                puzzleHeight = availableHeight;
                puzzleWidth = puzzleHeight * imageAspect;
            } else {
                puzzleWidth = availableWidth;
                puzzleHeight = puzzleWidth / imageAspect;
            }
            
            // Set canvas size with device pixel ratio for sharp rendering
            const dpr = Math.min(window.devicePixelRatio || 1, 2); // Cap at 2x for performance
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            ctx.scale(dpr, dpr);
            
            pieceWidth = puzzleWidth / PUZZLE_COLS;
            pieceHeight = puzzleHeight / PUZZLE_ROWS;
            
            // Center the puzzle board
            offsetX = (window.innerWidth - puzzleWidth) / 2;
            offsetY = (window.innerHeight - puzzleHeight) / 2 + headerHeight / 2;
            
            createPieces();
            scatterPieces();
            startTimer();
            attachEventListeners();
            
            if (animationFrame) cancelAnimationFrame(animationFrame);
            draw();
        }

        function createPieces() {
            pieces = [];
            for (let row = 0; row < PUZZLE_ROWS; row++) {
                for (let col = 0; col < PUZZLE_COLS; col++) {
                    pieces.push({
                        correctX: offsetX + col * pieceWidth,
                        correctY: offsetY + row * pieceHeight,
                        currentX: 0,
                        currentY: 0,
                        col: col,
                        row: row,
                        placed: false,
                        zIndex: row * PUZZLE_COLS + col
                    });
                }
            }
        }

        function scatterPieces() {
            const margin = 60;
            const gridCols = Math.ceil(Math.sqrt(pieces.length));
            const gridSize = Math.min(
                (window.innerWidth - margin * 2) / gridCols,
                (window.innerHeight - margin * 2) / gridCols
            );
            
            pieces.forEach((piece, index) => {
                const gridRow = Math.floor(index / gridCols);
                const gridCol = index % gridCols;
                
                // Base position in grid
                let baseX = margin + gridCol * gridSize;
                let baseY = margin + gridRow * gridSize;
                
                // Add randomization within grid cell
                const randomX = (Math.random() - 0.5) * (gridSize - pieceWidth - 20);
                const randomY = (Math.random() - 0.5) * (gridSize - pieceHeight - 20);
                
                piece.currentX = Math.max(margin, Math.min(
                    window.innerWidth - pieceWidth - margin,
                    baseX + randomX
                ));
                piece.currentY = Math.max(margin, Math.min(
                    window.innerHeight - pieceHeight - margin,
                    baseY + randomY
                ));
                
                // Ensure pieces don't start on correct position
                if (Math.abs(piece.currentX - piece.correctX) < 50 && 
                    Math.abs(piece.currentY - piece.correctY) < 50) {
                    piece.currentX += 100;
                }
            });
        }

        // ==================== EVENT HANDLING ====================
        function attachEventListeners() {
            canvas.removeEventListener('mousedown', handleStart);
            canvas.removeEventListener('mousemove', handleMove);
            canvas.removeEventListener('mouseup', handleEnd);
            canvas.removeEventListener('touchstart', handleStart);
            canvas.removeEventListener('touchmove', handleMove);
            canvas.removeEventListener('touchend', handleEnd);
            
            canvas.addEventListener('mousedown', handleStart);
            canvas.addEventListener('mousemove', handleMove);
            canvas.addEventListener('mouseup', handleEnd);
            canvas.addEventListener('touchstart', handleStart, { passive: false });
            canvas.addEventListener('touchmove', handleMove, { passive: false });
            canvas.addEventListener('touchend', handleEnd, { passive: false });
        }

        function handleStart(e) {
            if (isCompleted) return;
            e.preventDefault();
            
            const pos = getEventPosition(e);
            
            // Find topmost piece under pointer
            const sortedPieces = [...pieces].sort((a, b) => b.zIndex - a.zIndex);
            
            for (let piece of sortedPieces) {
                if (!piece.placed &&
                    pos.x >= piece.currentX &&
                    pos.x <= piece.currentX + pieceWidth &&
                    pos.y >= piece.currentY &&
                    pos.y <= piece.currentY + pieceHeight) {
                    
                    draggedPiece = piece;
                    dragOffset.x = pos.x - piece.currentX;
                    dragOffset.y = pos.y - piece.currentY;
                    
                    // Bring to front
                    const maxZ = Math.max(...pieces.map(p => p.zIndex));
                    piece.zIndex = maxZ + 1;
                    break;
                }
            }
        }

        function handleMove(e) {
            if (!draggedPiece) return;
            e.preventDefault();
            
            const pos = getEventPosition(e);
            draggedPiece.currentX = pos.x - dragOffset.x;
            draggedPiece.currentY = pos.y - dragOffset.y;
        }

        function handleEnd(e) {
            if (!draggedPiece) return;
            e.preventDefault();
            
            // Check if piece is close to correct position
            const dx = draggedPiece.currentX - draggedPiece.correctX;
            const dy = draggedPiece.currentY - draggedPiece.correctY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < SNAP_DISTANCE) {
                draggedPiece.currentX = draggedPiece.correctX;
                draggedPiece.currentY = draggedPiece.correctY;
                draggedPiece.placed = true;
                
                // Haptic feedback on mobile
                if (navigator.vibrate) {
                    navigator.vibrate(50);
                }
                
                checkCompletion();
            }
            
            draggedPiece = null;
        }

        function getEventPosition(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0] && e.touches[0].clientX) || 0;
            const clientY = e.clientY || (e.touches && e.touches[0] && e.touches[0].clientY) || 0;
            
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        // ==================== RENDERING ====================
        function draw() {
            // Clear canvas with background
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
            
            // Draw ghost positions for unplaced pieces
            pieces.forEach(piece => {
                if (!piece.placed) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(
                        piece.correctX + 1, 
                        piece.correctY + 1, 
                        pieceWidth - 2, 
                        pieceHeight - 2
                    );
                    ctx.setLineDash([]);
                }
            });
            
            // Sort pieces by zIndex for proper layering
            const sortedPieces = [...pieces].sort((a, b) => a.zIndex - b.zIndex);
            
            // Draw pieces
            sortedPieces.forEach(piece => {
                const sx = piece.col * (puzzleImage.width / PUZZLE_COLS);
                const sy = piece.row * (puzzleImage.height / PUZZLE_ROWS);
                const sw = puzzleImage.width / PUZZLE_COLS;
                const sh = puzzleImage.height / PUZZLE_ROWS;
                
                ctx.save();
                
                // Shadow for floating pieces
                if (!piece.placed && piece !== draggedPiece) {
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                    ctx.shadowBlur = 10;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 3;
                } else if (piece === draggedPiece) {
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    ctx.shadowBlur = 20;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 8;
                }
                
                // Draw piece image
                ctx.drawImage(
                    puzzleImage,
                    sx, sy, sw, sh,
                    Math.round(piece.currentX), 
                    Math.round(piece.currentY), 
                    Math.round(pieceWidth), 
                    Math.round(pieceHeight)
                );
                
                ctx.restore();
                
                // Border
                if (piece === draggedPiece) {
                    ctx.strokeStyle = 'rgba(74, 222, 128, 0.8)';
                    ctx.lineWidth = 3;
                } else if (piece.placed) {
                    ctx.strokeStyle = 'rgba(74, 222, 128, 0.3)';
                    ctx.lineWidth = 1;
                } else {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.lineWidth = 1.5;
                }
                
                ctx.strokeRect(
                    Math.round(piece.currentX), 
                    Math.round(piece.currentY), 
                    Math.round(pieceWidth), 
                    Math.round(pieceHeight)
                );
            });
            
            animationFrame = requestAnimationFrame(draw);
        }

        // ==================== TIMER ====================
        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);
            startTime = Date.now();
            updateTimer();
            timerInterval = setInterval(updateTimer, 1000);
        }

        function updateTimer() {
            if (isCompleted) return;
            
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const seconds = (elapsed % 60).toString().padStart(2, '0');
            document.getElementById('timer').textContent = `${minutes}:${seconds}`;
        }

        function checkCompletion() {
            if (pieces.every(piece => piece.placed)) {
                isCompleted = true;
                clearInterval(timerInterval);
                
                const finalTime = document.getElementById('timer').textContent;
                document.getElementById('finalTime').textContent = finalTime;
                
                // Haptic feedback
                if (navigator.vibrate) {
                    navigator.vibrate([100, 50, 100, 50, 200]);
                }
                
                setTimeout(() => {
                    document.getElementById('completionModal').classList.add('show');
                }, 600);
            }
        }

        function resetPuzzle() {
            document.getElementById('completionModal').classList.remove('show');
            isCompleted = false;
            pieces.forEach(piece => {
                piece.placed = false;
                piece.zIndex = piece.row * PUZZLE_COLS + piece.col;
            });
            scatterPieces();
            startTimer();
        }

        // ==================== WINDOW RESIZE ====================
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (puzzleImage && puzzleImage.complete) {
                    // Preserve placed pieces state during resize
                    const wasCompleted = isCompleted;
                    setupPuzzle();
                    isCompleted = wasCompleted;
                }
            }, 250);
        });
    </script>
</body>
</html>